<!-- <rosieArtifact title="Twilight Kart Racer">
<rosieCreate file="index.html">
<![CDATA[
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Twilight Kart Racer</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://esm.sh/three@0.160.0?dev",
          "three/": "https://esm.sh/three@0.160.0&dev/"
        }
      }
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: 'Arial', sans-serif;
      }
      
      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        z-index: 100;
      }
      
      #speedometer {
        position: absolute;
        bottom: 30px;
        right: 30px;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: rgba(0,0,0,0.8);
        border: 3px solid #fff;
        z-index: 100;
      }
      
      #abilities {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 14px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        z-index: 100;
      }
      
      .ability {
        margin-bottom: 8px;
        padding: 5px 10px;
        background: rgba(0,0,0,0.6);
        border-radius: 5px;
      }
      
      .ability.active {
        background: rgba(0,200,255,0.8);
        animation: pulse 0.5s ease-in-out infinite alternate;
      }
      
      @keyframes pulse {
        from { opacity: 0.8; }
        to { opacity: 1; }
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div id="ui">
        <div>Speed: <span id="speedDisplay">0</span> mph</div>
        <div>Lap Time: <span id="lapTime">0:00</span></div>
      </div>
      
      <div id="abilities">
        <div class="ability" id="boostAbility">SHIFT - Speed Boost</div>
        <div class="ability" id="jumpAbility">CTRL+SPACE - Super Jump</div>
        <div class="ability" id="shieldAbility">E - Shield</div>
      </div>
      
      <canvas id="speedometer"></canvas>
    </div>
    
    <script type="module" src="main.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ChatManager.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ImageGenerator.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/ProgressLogger.js"></script>
    <script src="https://storage.googleapis.com/rosebud_staticfiles/OGP.js"></script>
  </body>
</html>
]]>
</rosieCreate>

<rosieCreate file="main.js">
<![CDATA[
import * as THREE from 'three';
import { FirstPersonCameraController } from './rosieControls.js';
import { Kart } from './kart.js';
import { Track } from './track.js';
import { Environment } from './environment.js';
import { UI } from './ui.js';

class TwilightKartRacer {
  constructor() {
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.clock = new THREE.Clock();
    
    this.setupRenderer();
    this.createWorld();
    this.setupControls();
    this.setupEventListeners();
    
    this.gameLoop();
  }
  
  setupRenderer() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    this.renderer.setClearColor(0x2a1845);
    document.getElementById('gameContainer').appendChild(this.renderer.domElement);
  }
  
  createWorld() {
    // Create environment first for proper lighting
    this.environment = new Environment(this.scene);
    
    // Create track
    this.track = new Track(this.scene);
    
    // Create kart
    this.kart = new Kart(this.scene);
    
    // Create UI
    this.ui = new UI();
    
    // Position camera inside kart
    this.camera.position.set(0, 1.2, 0);
  }
  
  setupControls() {
    // Use first-person controller for cockpit view
    this.cameraController = new FirstPersonCameraController(
      this.camera, 
      this.kart.mesh, 
      this.renderer.domElement,
      {
        eyeHeight: 1.2,
        mouseSensitivity: 0.001
      }
    );
    this.cameraController.enable();
  }
  
  setupEventListeners() {
    window.addEventListener('resize', () => this.onWindowResize());
    
    // Kart controls
    this.keys = {};
    window.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
      this.kart.handleKeyDown(e.code);
    });
    
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
      this.kart.handleKeyUp(e.code);
    });
  }
  
  onWindowResize() {
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  gameLoop() {
    requestAnimationFrame(() => this.gameLoop());
    
    const deltaTime = this.clock.getDelta();
    
    // Update kart physics and abilities
    this.kart.update(deltaTime, this.keys);
    
    // Update camera
    this.cameraController.update();
    
    // Update UI
    this.ui.update(this.kart.speed, this.kart.abilities);
    
    // Render
    this.renderer.render(this.scene, this.camera);
  }
}

// Start the game
new TwilightKartRacer();
]]>
</rosieCreate>

<rosieCreate file="kart.js">
<![CDATA[
import * as THREE from 'three';

export class Kart {
  constructor(scene) {
    this.scene = scene;
    this.mesh = this.createKart();
    this.scene.add(this.mesh);
    
    // Physics properties
    this.velocity = new THREE.Vector3();
    this.acceleration = 0;
    this.maxSpeed = 25;
    this.speed = 0;
    this.turnSpeed = 0;
    this.maxTurnSpeed = 2;
    
    // Abilities
    this.abilities = {
      boost: { active: false, cooldown: 0, duration: 0 },
      jump: { active: false, cooldown: 0 },
      shield: { active: false, cooldown: 0, duration: 0 }
    };
    
    // Effects
    this.particles = this.createParticleSystem();
    this.shakeIntensity = 0;
  }
  
  createKart() {
    const kart = new THREE.Group();
    
    // Main body - blue and colorful like the reference
    const bodyGeometry = new THREE.BoxGeometry(1.2, 0.4, 2);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00aaff });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.6;
    kart.add(body);
    
    // Side panels - bright accent colors
    const leftPanel = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.3, 1.5),
      new THREE.MeshLambertMaterial({ color: 0xff3366 })
    );
    leftPanel.position.set(-0.6, 0.6, 0);
    kart.add(leftPanel);
    
    const rightPanel = leftPanel.clone();
    rightPanel.position.x = 0.6;
    kart.add(rightPanel);
    
    // Front nose
    const noseGeometry = new THREE.ConeGeometry(0.3, 0.6, 8);
    const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
    const nose = new THREE.Mesh(noseGeometry, noseMaterial);
    nose.position.set(0, 0.6, 1.2);
    nose.rotation.x = Math.PI / 2;
    kart.add(nose);
    
    // Wheels
    for (let i = 0; i < 4; i++) {
      const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 12);
      const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
      const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      
      const x = i % 2 === 0 ? -0.8 : 0.8;
      const z = i < 2 ? 0.8 : -0.8;
      wheel.position.set(x, 0.3, z);
      wheel.rotation.z = Math.PI / 2;
      kart.add(wheel);
    }
    
    kart.position.y = 0.75;
    return kart;
  }
  
  createParticleSystem() {
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(100 * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
      color: 0x00aaff,
      size: 0.1,
      transparent: true,
      opacity: 0.6
    });
    
    const particles = new THREE.Points(geometry, material);
    this.scene.add(particles);
    return particles;
  }
  
  handleKeyDown(keyCode) {
    // Boost ability
    if (keyCode === 'ShiftLeft' || keyCode === 'ShiftRight') {
      this.activateBoost();
    }
    
    // Jump ability
    if (keyCode === 'Space' && (keyCode === 'ControlLeft' || keyCode === 'ControlRight')) {
      this.activateJump();
    }
    
    // Shield ability
    if (keyCode === 'KeyE') {
      this.activateShield();
    }
  }
  
  handleKeyUp(keyCode) {
    // Handle key releases if needed
  }
  
  activateBoost() {
    if (this.abilities.boost.cooldown <= 0) {
      this.abilities.boost.active = true;
      this.abilities.boost.duration = 2.0;
      this.abilities.boost.cooldown = 5.0;
      
      // Visual effect
      this.particles.material.color.setHex(0xff6600);
      this.shakeIntensity = 0.02;
    }
  }
  
  activateJump() {
    if (this.abilities.jump.cooldown <= 0) {
      this.abilities.jump.active = true;
      this.abilities.jump.cooldown = 3.0;
      this.velocity.y = 12;
      
      // Visual effect
      this.shakeIntensity = 0.03;
    }
  }
  
  activateShield() {
    if (this.abilities.shield.cooldown <= 0) {
      this.abilities.shield.active = true;
      this.abilities.shield.duration = 3.0;
      this.abilities.shield.cooldown = 8.0;
      
      // Create shield visual
      if (!this.shieldMesh) {
        const shieldGeometry = new THREE.SphereGeometry(2, 16, 16);
        const shieldMaterial = new THREE.MeshLambertMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.3
        });
        this.shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
        this.mesh.add(this.shieldMesh);
      }
      this.shieldMesh.visible = true;
    }
  }
  
  update(deltaTime, keys) {
    // Handle movement input
    let accelerationInput = 0;
    let turnInput = 0;
    
    if (keys['KeyW'] || keys['ArrowUp']) accelerationInput = 1;
    if (keys['KeyS'] || keys['ArrowDown']) accelerationInput = -0.5;
    if (keys['KeyA'] || keys['ArrowLeft']) turnInput = -1;
    if (keys['KeyD'] || keys['ArrowRight']) turnInput = 1;
    
    // Update abilities
    this.updateAbilities(deltaTime);
    
    // Apply boost
    let speedMultiplier = 1;
    if (this.abilities.boost.active) {
      speedMultiplier = 2.0;
    }
    
    // Update physics
    this.acceleration = accelerationInput * 15 * speedMultiplier;
    this.speed += this.acceleration * deltaTime;
    this.speed = Math.max(0, Math.min(this.speed, this.maxSpeed * speedMultiplier));
    
    // Natural deceleration
    if (accelerationInput === 0) {
      this.speed *= 0.95;
    }
    
    // Turning (only when moving)
    if (this.speed > 0.1) {
      this.turnSpeed = turnInput * this.maxTurnSpeed * (this.speed / this.maxSpeed);
      this.mesh.rotation.y += this.turnSpeed * deltaTime;
    }
    
    // Move forward
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(this.mesh.quaternion);
    
    this.velocity.x = forward.x * this.speed;
    this.velocity.z = forward.z * this.speed;
    
    // Apply gravity and jumping
    if (this.mesh.position.y > 0.75) {
      this.velocity.y -= 25 * deltaTime;
    } else {
      this.mesh.position.y = 0.75;
      this.velocity.y = 0;
      this.abilities.jump.active = false;
    }
    
    // Update position
    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
    
    // Update camera shake
    if (this.shakeIntensity > 0) {
      this.shakeIntensity *= 0.9;
      if (this.shakeIntensity < 0.001) this.shakeIntensity = 0;
    }
    
    // Update particle effects
    this.updateParticles();
  }
  
  updateAbilities(deltaTime) {
    // Update boost
    if (this.abilities.boost.active) {
      this.abilities.boost.duration -= deltaTime;
      if (this.abilities.boost.duration <= 0) {
        this.abilities.boost.active = false;
        this.particles.material.color.setHex(0x00aaff);
      }
    }
    if (this.abilities.boost.cooldown > 0) {
      this.abilities.boost.cooldown -= deltaTime;
    }
    
    // Update jump cooldown
    if (this.abilities.jump.cooldown > 0) {
      this.abilities.jump.cooldown -= deltaTime;
    }
    
    // Update shield
    if (this.abilities.shield.active) {
      this.abilities.shield.duration -= deltaTime;
      if (this.abilities.shield.duration <= 0) {
        this.abilities.shield.active = false;
        if (this.shieldMesh) this.shieldMesh.visible = false;
      }
    }
    if (this.abilities.shield.cooldown > 0) {
      this.abilities.shield.cooldown -= deltaTime;
    }
  }
  
  updateParticles() {
    // Update particle positions for trail effect
    const positions = this.particles.geometry.attributes.position.array;
    
    for (let i = positions.length - 3; i >= 3; i -= 3) {
      positions[i] = positions[i - 3];
      positions[i + 1] = positions[i - 2];
      positions[i + 2] = positions[i - 1];
    }
    
    // Add new particle at kart position
    positions[0] = this.mesh.position.x + (Math.random() - 0.5) * 0.5;
    positions[1] = this.mesh.position.y + 0.2;
    positions[2] = this.mesh.position.z + (Math.random() - 0.5) * 0.5;
    
    this.particles.geometry.attributes.position.needsUpdate = true;
  }
}
]]>
</rosieCreate>

<rosieCreate file="track.js">
<![CDATA[
import * as THREE from 'three';

export class Track {
  constructor(scene) {
    this.scene = scene;
    this.createTrack();
    this.createBarriers();
    this.createEnvironmentDetails();
  }
  
  createTrack() {
    // Main track surface
    const trackGeometry = new THREE.PlaneGeometry(100, 500);
    const trackMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x4a4a4a,
      transparent: true,
      opacity: 0.9
    });
    const track = new THREE.Mesh(trackGeometry, trackMaterial);
    track.rotation.x = -Math.PI / 2;
    this.scene.add(track);
    
    // Track lane markings - yellow center lines
    this.createLaneMarkings();
    
    // Track borders
    const borderMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
    
    const leftBorder = new THREE.Mesh(
      new THREE.PlaneGeometry(2, 500),
      borderMaterial
    );
    leftBorder.rotation.x = -Math.PI / 2;
    leftBorder.position.x = -51;
    this.scene.add(leftBorder);
    
    const rightBorder = leftBorder.clone();
    rightBorder.position.x = 51;
    this.scene.add(rightBorder);
  }
  
  createLaneMarkings() {
    const markingMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
    
    // Center dashed line
    for (let i = -240; i < 240; i += 20) {
      const marking = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 8),
        markingMaterial
      );
      marking.rotation.x = -Math.PI / 2;
      marking.position.set(0, 0.01, i);
      this.scene.add(marking);
    }
    
    // Side lines
    const leftLine = new THREE.Mesh(
      new THREE.PlaneGeometry(0.2, 500),
      markingMaterial
    );
    leftLine.rotation.x = -Math.PI / 2;
    leftLine.position.set(-25, 0.01, 0);
    this.scene.add(leftLine);
    
    const rightLine = leftLine.clone();
    rightLine.position.x = 25;
    this.scene.add(rightLine);
  }
  
  createBarriers() {
    // Red and white striped barriers like in the reference image
    const barrierGroup = new THREE.Group();
    
    for (let side = -1; side <= 1; side += 2) {
      for (let i = -250; i < 250; i += 10) {
        const barrier = this.createStripedBarrier();
        barrier.position.set(side * 35, 1, i);
        this.scene.add(barrier);
      }
    }
  }
  
  createStripedBarrier() {
    const barrier = new THREE.Group();
    
    // Create striped pattern
    const stripeColors = [0xff0000, 0xffffff]; // Red and white
    
    for (let i = 0; i < 10; i++) {
      const stripeGeometry = new THREE.BoxGeometry(2, 2, 1);
      const stripeMaterial = new THREE.MeshLambertMaterial({ 
        color: stripeColors[i % 2] 
      });
      const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
      stripe.position.z = i - 4.5;
      barrier.add(stripe);
    }
    
    return barrier;
  }
  
  createEnvironmentDetails() {
    // Power line poles in the distance (like in reference)
    for (let i = -200; i < 200; i += 40) {
      const pole = this.createPowerPole();
      pole.position.set(-80 + Math.random() * 20, 0, i);
      this.scene.add(pole);
      
      const pole2 = this.createPowerPole();
      pole2.position.set(80 + Math.random() * 20, 0, i);
      this.scene.add(pole2);
    }
    
    // Additional track details
    this.createTrackSigns();
  }
  
  createPowerPole() {
    const pole = new THREE.Group();
    
    // Main pole
    const poleGeometry = new THREE.CylinderGeometry(0.2, 0.3, 15);
    const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const mainPole = new THREE.Mesh(poleGeometry, poleMaterial);
    mainPole.position.y = 7.5;
    pole.add(mainPole);
    
    // Cross beam
    const beamGeometry = new THREE.BoxGeometry(4, 0.3, 0.3);
    const beam = new THREE.Mesh(beamGeometry, poleMaterial);
    beam.position.y = 12;
    pole.add(beam);
    
    return pole;
  }
  
  createTrackSigns() {
    // Simple track signs for visual interest
    for (let i = -150; i < 150; i += 80) {
      const sign = new THREE.Group();
      
      const signPost = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 3),
        new THREE.MeshLambertMaterial({ color: 0x666666 })
      );
      signPost.position.y = 1.5;
      sign.add(signPost);
      
      const signBoard = new THREE.Mesh(
        new THREE.BoxGeometry(2, 1, 0.1),
        new THREE.MeshLambertMaterial({ color: 0x0066cc })
      );
      signBoard.position.y = 2.5;
      sign.add(signBoard);
      
      sign.position.set(-45, 0, i);
      this.scene.add(sign);
      
      const sign2 = sign.clone();
      sign2.position.x = 45;
      this.scene.add(sign2);
    }
  }
}
]]>
</rosieCreate>

<rosieCreate file="environment.js">
<![CDATA[
import * as THREE from 'three';

export class Environment {
  constructor(scene) {
    this.scene = scene;
    this.createSky();
    this.createMountains();
    this.setupLighting();
    this.createAtmosphere();
  }
  
  createSky() {
    // Create gradient sky matching the reference image
    const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
    
    // Create custom gradient material
    const skyMaterial = new THREE.ShaderMaterial({
      uniforms: {
        topColor: { value: new THREE.Color(0x2a1845) }, // Deep purple
        horizonColor: { value: new THREE.Color(0x8B4B8C) }, // Purple-pink
        bottomColor: { value: new THREE.Color(0xFF6B47) }, // Orange-pink
        offset: { value: 0.1 },
        exponent: { value: 0.6 }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 horizonColor;
        uniform vec3 bottomColor;
        uniform float offset;
        uniform float exponent;
        varying vec3 vWorldPosition;
        
        void main() {
          float h = normalize(vWorldPosition + offset).y;
          
          if (h > 0.3) {
            gl_FragColor = vec4(mix(horizonColor, topColor, pow(max(h - 0.3, 0.0) / 0.7, exponent)), 1.0);
          } else {
            gl_FragColor = vec4(mix(bottomColor, horizonColor, pow(max(h, 0.0) / 0.3, exponent)), 1.0);
          }
        }
      `,
      side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    this.scene.add(sky);
  }
  
  createMountains() {
    // Create silhouetted mountains in the background
    const mountainColors = [0x1a0f2e, 0x2a1845, 0x3a2855]; // Various dark purples
    
    // Background mountain layers
    for (let layer = 0; layer < 3; layer++) {
      const mountainGroup = new THREE.Group();
      
      for (let i = 0; i < 8; i++) {
        const mountain = this.createMountain(mountainColors[layer]);
        mountain.position.x = (i - 4) * 80 + (Math.random() - 0.5) * 30;
        mountain.position.z = -150 - layer * 50;
        mountain.position.y = -10;
        mountain.scale.y = 0.8 + Math.random() * 0.4;
        mountain.scale.x = 0.6 + Math.random() * 0.8;
        mountainGroup.add(mountain);
      }
      
      this.scene.add(mountainGroup);
    }
  }
  
  createMountain(color) {
    // Create irregular mountain shape
    const points = [];
    const segments = 12;
    
    for (let i = 0; i <= segments; i++) {
      const angle = (i / segments) * Math.PI;
      const radius = 40 + Math.random() * 20;
      const height = Math.sin(angle) * (30 + Math.random() * 40);
      
      points.push(new THREE.Vector2(
        Math.cos(angle) * radius,
        height
      ));
    }
    
    const mountainGeometry = new THREE.LatheGeometry(points, 16);
    const mountainMaterial = new THREE.MeshLambertMaterial({ 
      color: color,
      transparent: true,
      opacity: 0.8
    });
    
    return new THREE.Mesh(mountainGeometry, mountainMaterial);
  }
  
  setupLighting() {
    // Ambient light for overall illumination
    const ambientLight = new THREE.AmbientLight(0x4a3870, 0.6);
    this.scene.add(ambientLight);
    
    // Main directional light (sunset lighting)
    const directionalLight = new THREE.DirectionalLight(0xffa500, 0.8);
    directionalLight.position.set(-50, 30, -20);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    this.scene.add(directionalLight);
    
    // Additional warm light for atmosphere
    const warmLight = new THREE.DirectionalLight(0xff6b47, 0.4);
    warmLight.position.set(30, 20, 10);
    this.scene.add(warmLight);
    
    // Cool blue light for contrast
    const coolLight = new THREE.DirectionalLight(0x4a70ff, 0.3);
    coolLight.position.set(0, 50, 100);
    this.scene.add(coolLight);
  }
  
  createAtmosphere() {
    // Add fog for depth and atmosphere
    this.scene.fog = new THREE.Fog(0x6b4b8c, 50, 300);
    
    // Create floating particles for atmosphere
    this.createAtmosphericParticles();
  }
  
  createAtmosphericParticles() {
    const particleCount = 200;
    const positions = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 400;
      positions[i * 3 + 1] = Math.random() * 100 + 20;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
    }
    
    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 2,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Animate particles
    this.animateParticles(particles);
  }
  
  animateParticles(particles) {
    const animate = () => {
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.01;
        positions[i + 1] += 0.02;
        
        if (positions[i + 1] > 120) {
          positions[i + 1] = 20;
        }
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      requestAnimationFrame(animate);
    };
    
    animate();
  }
}
]]>
</rosieCreate>

<rosieCreate file="ui.js">
<![CDATA[
export class UI {
  constructor() {
    this.speedDisplay = document.getElementById('speedDisplay');
    this.lapTime = document.getElementById('lapTime');
    this.startTime = Date.now();
    
    // Ability UI elements
    this.boostAbility = document.getElementById('boostAbility');
    this.jumpAbility = document.getElementById('jumpAbility');
    this.shieldAbility = document.getElementById('shieldAbility');
    
    this.setupSpeedometer();
  }
  
  setupSpeedometer() {
    const canvas = document.getElementById('speedometer');
    canvas.width = 120;
    canvas.height = 120;
    this.ctx = canvas.getContext('2d');
    
    // Style the canvas
    canvas.style.position = 'absolute';
    canvas.style.bottom = '30px';
    canvas.style.right = '30px';
    canvas.style.border = '3px solid white';
    canvas.style.borderRadius = '50%';
    canvas.style.background = 'rgba(0,0,0,0.8)';
  }
  
  update(speed, abilities) {
    // Update speed display
    const mph = Math.round(speed * 2.237); // Convert to mph
    this.speedDisplay.textContent = mph;
    
    // Update lap time
    const elapsed = Date.now() - this.startTime;
    const minutes = Math.floor(elapsed / 60000);
    const seconds = Math.floor((elapsed % 60000) / 1000);
    this.lapTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Update speedometer
    this.drawSpeedometer(speed);
    
    // Update ability indicators
    this.updateAbilityUI(abilities);
  }
  
  drawSpeedometer(speed) {
    const ctx = this.ctx;
    const centerX = 60;
    const centerY = 60;
    const radius = 45;
    
    // Clear canvas
    ctx.clearRect(0, 0, 120, 120);
    
    // Draw outer ring
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw speed marks
    for (let i = 0; i <= 12; i++) {
      const angle = (i / 12) * 2 * Math.PI - Math.PI / 2;
      const startX = centerX + Math.cos(angle) * (radius - 10);
      const startY = centerY + Math.sin(angle) * (radius - 10);
      const endX = centerX + Math.cos(angle) * (radius - 5);
      const endY = centerY + Math.sin(angle) * (radius - 5);
      
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = i % 3 === 0 ? '#ffffff' : '#888888';
      ctx.lineWidth = i % 3 === 0 ? 2 : 1;
      ctx.stroke();
    }
    
    // Draw speed needle
    const speedAngle = (speed / 25) * (3/4) * 2 * Math.PI - Math.PI / 2;
    const needleEndX = centerX + Math.cos(speedAngle) * (radius - 15);
    const needleEndY = centerY + Math.sin(speedAngle) * (radius - 15);
    
    ctx.beginPath();
    ctx.moveTo(centerX, centerY);
    ctx.lineTo(needleEndX, needleEndY);
    ctx.strokeStyle = '#ff3333';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Draw center dot
    ctx.beginPath();
    ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    
    // Draw speed text
    ctx.fillStyle = '#ffffff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    const mph = Math.round(speed * 2.237);
    ctx.fillText(mph.toString(), centerX, centerY + 25);
    ctx.font = '8px Arial';
    ctx.fillText('MPH', centerX, centerY + 35);
  }
  
  updateAbilityUI(abilities) {
    // Update boost indicator
    if (abilities.boost.active) {
      this.boostAbility.classList.add('active');
      this.boostAbility.textContent = 'BOOST ACTIVE!';
    } else if (abilities.boost.cooldown > 0) {
      this.boostAbility.classList.remove('active');
      this.boostAbility.textContent = `SHIFT - Boost (${Math.ceil(abilities.boost.cooldown)}s)`;
    } else {
      this.boostAbility.classList.remove('active');
      this.boostAbility.textContent = 'SHIFT - Speed Boost';
    }
    
    // Update jump indicator
    if (abilities.jump.cooldown > 0) {
      this.jumpAbility.textContent = `CTRL+SPACE - Jump (${Math.ceil(abilities.jump.cooldown)}s)`;
    } else {
      this.jumpAbility.textContent = 'CTRL+SPACE - Super Jump';
    }
    
    // Update shield indicator
    if (abilities.shield.active) {
      this.shieldAbility.classList.add('active');
      this.shieldAbility.textContent = 'SHIELD ACTIVE!';
    } else if (abilities.shield.cooldown > 0) {
      this.shieldAbility.classList.remove('active');
      this.shieldAbility.textContent = `E - Shield (${Math.ceil(abilities.shield.cooldown)}s)`;
    } else {
      this.shieldAbility.classList.remove('active');
      this.shieldAbility.textContent = 'E - Shield';
    }
  }
}
]]>
</rosieCreate>
</rosieArtifact> -->
